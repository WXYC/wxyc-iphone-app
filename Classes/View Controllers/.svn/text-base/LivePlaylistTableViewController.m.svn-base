//
//  Created by Jake Bromberg.
//  Copyright WXYC 2009-10. All rights reserved.
//

#import "LivePlaylistTableViewController.h"
#import "PlaycutDetailsViewController.h"
#import "WXYCAppDelegate.h"
#import "JSON.h"
#import	"BreakpointTableViewCell.h"
#import "ButtonTableViewCell.h"
#import "PlaylistController.h"
#import "NSDictionaryToPlaylistEntryMapper.h"
#import "PlaycutViewController.h"
#import "WXYCDataStack.h"

@implementation LivePlaylistTableViewController

static const int kNumEntriesToFetch = 18;
static int entriesMultiplier = 1;

- (void)controllerContextDidSave:(NSNotification *)aNotification {
	[managedObjectContext mergeChangesFromContextDidSaveNotification:aNotification];
	NSLog(@"NSPredicate %@", [request predicate]);
	
	NSError *error = nil;
	NSMutableArray *mutableFetchResults = [[managedObjectContext executeFetchRequest:request error:&error] mutableCopy];
	if (mutableFetchResults == nil) {
		// Handle the error.
	}
	
	//[self setFavoritesArray:mutableFetchResults];
	
	[self.tableView reloadData];
}

#pragma mark RefreshHeaderView

- (void) reloadTableViewDataSource
{
	[livePlaylistCtrl updatePlaylist];
}

- (void)livePlaylistControllerStateChanged:(NSNotification *)aNotification
{
	if ([livePlaylistCtrl getState] == LP_DONE) {
		[refreshHeaderView setLastUpdatedDate:[NSDate date]];
		[self.tableView reloadData];
		[super dataSourceDidFinishLoadingNewData];
	}
}

#pragma mark -
#pragma mark UITableViewController

- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView {
    // 1 section
    return 1;
}

- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section {
	if ([livePlaylistCtrl.playlist count]==0) {
		return 0;
	}

//	NSLog(@"([livePlaylistCtrl.playlist count]*entriesMultiplier)+1 %i", ([livePlaylistCtrl.playlist count]*entriesMultiplier)+1);
//	NSLog(@"[livePlaylistCtrl.playlist count] %i entriesMultiplier %i", [livePlaylistCtrl.playlist count], entriesMultiplier);
	
    return (kNumEntriesToFetch*entriesMultiplier)+1;
}

- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath {
	if ([livePlaylistCtrl.playlist count] == 0) {
		return [tableView dequeueReusableCellWithIdentifier:@"Cell"];	
	}

	NSUInteger row = [indexPath row];
	
	if (row == (kNumEntriesToFetch*entriesMultiplier))//[livePlaylistCtrl.playlist count])
	{
		NSArray* topLevelObjects = 
		[[NSBundle mainBundle]
		 loadNibNamed:@"ButtonTableViewCell" 
		 owner:nil options:nil];
		
		ButtonTableViewCell *buttonCell = (ButtonTableViewCell *)[topLevelObjects objectAtIndex:0];
		
		buttonCell.description.text = @"Previously, on WXYCâ€¦";
		buttonCell.description.textColor = [UIColor blueColor];
		buttonCell.backgroundView.backgroundColor = [UIColor colorWithRed:226.0/255.0 
																	green:231.0/255.0 blue:237.0/255.0 alpha:1.0];
				
		return buttonCell;
	}
	
	NSDictionary *playlistEntry = [livePlaylistCtrl.playlist objectAtIndex:row];
    UITableViewCell *cell;
	NSString *entryType = [NSString stringWithFormat: @"%@", [playlistEntry objectForKey:@"entryType"]];
	
	if ([entryType isEqualToString:@"playcut"] )
	{
		NSDictionary *playcut = [playlistEntry objectForKey:@"playcut"];
		
		cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleSubtitle reuseIdentifier:@"Cell"];
		
		NSString *artistName = [NSString stringWithFormat: @"%@", [playcut objectForKey:@"artistName"]];
		cell.textLabel.text = artistName;
		
		NSString *songTitle = [NSString stringWithFormat: @"%@", [playcut objectForKey:@"songTitle"]];
		cell.detailTextLabel.text = songTitle;
		
		[cell setBackgroundColor:[UIColor clearColor]];
		
		//NSLog(@"playcut cell height %f", cell.bounds.size.height);
	}
	else if ([entryType isEqualToString:@"talkset"] ) {
		cell = [[BreakpointTableViewCell alloc] initWithReuseIdentifier:@"BreakCell"];
		
		//Note to self:
		//casting the above call to (BreakpointTableViewCell*) will not suppress this warning
		[cell addText:@"TALKSET"];
	}
	else if ([entryType isEqualToString:@"breakpoint"] ) {
		cell = [[BreakpointTableViewCell alloc] initWithReuseIdentifier:@"BreakCell"];
		
		//date gymnastics to convert epoch timestamp to something readable
		double timeSinceEpoch = [[NSString stringWithFormat: @"%@", [playlistEntry objectForKey:@"hour"]] doubleValue] / 1000;
		NSDate *date = [NSDate dateWithTimeIntervalSince1970:timeSinceEpoch];
		
		NSDateFormatter* dateFormatter = [[[NSDateFormatter alloc] init] autorelease];
		dateFormatter.dateFormat = @"h:00 a";
		
		NSString* dateString = [dateFormatter stringFromDate:date];
		
		[((BreakpointTableViewCell*) cell) addText:dateString];
	}
	
//	NSLog(@"%@", [cell class]);

	return cell;
}

- (void) handleTimer: (NSTimer *) timer
{
	NSIndexPath* indexPath = [NSIndexPath indexPathForRow:[livePlaylistCtrl.playlist count] inSection:0];
	ButtonTableViewCell *buttonCell = (ButtonTableViewCell*) [self.tableView cellForRowAtIndexPath:indexPath];
	buttonCell.selectionStyle = UITableViewCellSelectionStyleNone;
}

- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath {
	NSUInteger row = [indexPath row];

	//boundary case
	if (row > [livePlaylistCtrl.playlist count]) {
		return 0;	
	}
	
	//"Previously, on WXYC..."
	//we don't roll this into the test below because [livePlaylistCtrl.playlist count] is out of bounds
	//to the playlist itself by 1.
	if (row == [livePlaylistCtrl.playlist count]) {
		return 44.0f;
	}

	NSDictionary *playlistEntry = [livePlaylistCtrl.playlist objectAtIndex:row];
	NSString *entryType = [NSString stringWithFormat: @"%@", [playlistEntry objectForKey:@"entryType"]];
	
	if ([entryType isEqualToString:@"breakpoint"] || [entryType isEqualToString:@"talkset"]) {
		return 21.0f;
	} else {
		return 44.0f;
	}
}

- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath {
	selectedRow = [indexPath row];
	
	if (self.reloading) //we'll crash if we do anything while the table's (re)loading
	{
		UITableViewCell* cell = [tableView cellForRowAtIndexPath:indexPath];
		[cell setSelected:NO animated:YES];
		return;
	}

	//Test if we selected a non-selectable cell (talkset or breakpoint)
	UITableViewCell *cell = [tableView cellForRowAtIndexPath:indexPath];
	if (cell.selectionStyle == UITableViewCellSelectionStyleNone) {
		return;
	}
	
	if ([indexPath row] == [livePlaylistCtrl.playlist count]) { //"Previously, on WXYC..."
		entriesMultiplier++;
		
		ButtonTableViewCell *buttonCell = (ButtonTableViewCell*) [tableView cellForRowAtIndexPath:indexPath];
		
		if ([buttonCell.activity isAnimating]) {
			//[buttonCell setSelected:NO animated:NO];
			buttonCell.selectionStyle = UITableViewCellSelectionStyleNone;

			return;
		}
		
		//Un-highlight the selected cell
		NSTimer *timer;
		timer = [NSTimer scheduledTimerWithTimeInterval: 0.25
												 target: self
											   selector: @selector(handleTimer:)
											   userInfo: nil
												repeats: NO];		
		
		[buttonCell setSelected:NO animated:YES];
		[buttonCell.activity startAnimating];
		[buttonCell.activity setHidesWhenStopped:NO];
		
		//Retrieve the previous 20 entries
		NSInteger referenceID = [[[livePlaylistCtrl.playlist objectAtIndex:[livePlaylistCtrl.playlist count]-1] objectForKey:@"chronOrderID"] intValue];
		[livePlaylistCtrl getJSONFeedWithNumEntries:(kNumEntriesToFetch+2) //+2 because the feed returns two less for some reason
										referenceID:referenceID 
										  direction:@"prev"];
		
		return;
	}
	
	//By process of elimination, we've selected a playcut cell
	PlaycutViewController *detail = [[[PlaycutViewController alloc] initWithNibName:@"DetailsView" bundle:nil] autorelease];
	[detail setDelegate:self];	
	detail.hidesBottomBarWhenPushed = YES;
	[[self navigationController] pushViewController:detail animated:YES];
}

#pragma mark -
#pragma mark UIViewController
- (void)viewDidLoad {
    [super viewDidLoad];

	managedObjectContext = [[WXYCDataStack sharedInstance] managedObjectContext];
	
	WXYCAppDelegate *appDelegate = (WXYCAppDelegate *)[[UIApplication sharedApplication] delegate];
	livePlaylistCtrl = [appDelegate livePlaylistCtrlr];

	if ((livePlaylistCtrl == nil) || [self reloading]) {
		livePlaylistCtrl = [[PlaylistController alloc] init];

		[self showReloadAnimationAnimated:YES];
		[self reloadTableViewDataSource];
	} else {
		[self.tableView reloadData];
	}
	
	[[NSNotificationCenter defaultCenter]
	 addObserver:self
	 selector:@selector(livePlaylistControllerStateChanged:)
	 name:LPStatusChangedNotification
	 object:nil];	
	
	[refreshHeaderView setLastUpdatedDate:[NSDate date]];
}

- (void)viewDidUnload {
	[dnc removeObserver:self name:NSManagedObjectContextDidSaveNotification object:managedObjectContext];
}

- (void)didReceiveMemoryWarning {
    [super didReceiveMemoryWarning]; // Releases the view if it doesn't have a superview
    // Release anything that's not essential, such as cached data
}

- (void)dealloc {
    [super dealloc];
}

#pragma mark -
#pragma mark NextPrevDetailsDelegate business
//THIS LOOKS LIKE CRAP. CHRIST.
-(id)NPnext {
	for (int i = selectedRow+1; i<[livePlaylistCtrl.playlist count]; i++) {
		NSDictionary *playlistEntry = [livePlaylistCtrl.playlist objectAtIndex:i];
		NSString *entryType = [NSString stringWithFormat: @"%@", [playlistEntry objectForKey:@"entryType"]];
		
		if ([entryType isEqualToString:@"playcut"] )
		{
			selectedRow = i;
			
			return [self NPcurrent];
		}
	}
	
	[self.tableView selectRowAtIndexPath:[NSIndexPath indexPathForRow:selectedRow inSection:0] 
	  animated:NO scrollPosition:UITableViewScrollPositionMiddle ];	

	return nil;
}

-(id)NPprev {
	for (int i = selectedRow-1; i>=0; i--) {
		NSDictionary *playlistEntry = [livePlaylistCtrl.playlist objectAtIndex:i];
		NSString *entryType = [NSString stringWithFormat: @"%@", [playlistEntry objectForKey:@"entryType"]];
		
		if ([entryType isEqualToString:@"playcut"] )
		{
			selectedRow = i;
			
			return [self NPcurrent];
		}
	}
	
	[self.tableView selectRowAtIndexPath:[NSIndexPath indexPathForRow:selectedRow inSection:0] 
	  animated:NO scrollPosition:UITableViewScrollPositionMiddle ];	
	
	return nil;	
}

-(id)NPcurrent {
	NSDictionary *playlistEntry = [livePlaylistCtrl.playlist objectAtIndex:selectedRow];
	NSDictionary *playcut = [playlistEntry objectForKey:@"playcut"];
	
	NSPredicate *predicate = [NSPredicate
							  predicateWithFormat:@"(Artist == %@) AND (Song == %@)",
							  [playcut objectForKey:@"artistName"], [playcut objectForKey:@"songTitle"]];
	
	//NSLog(@"Predicate %@", predicate);
	
	request = [[NSFetchRequest alloc] init];
	NSEntityDescription *entity = [NSEntityDescription entityForName:@"Playcut" inManagedObjectContext:managedObjectContext];
 	[request setEntity:entity];
	[request setPredicate:predicate];
	
	//NSLog(@"LivePlaylistTableViewController");
	
	NSArray *fetchResults = nil;
	NSError *error = nil;
	if (fetchResults = [managedObjectContext executeFetchRequest:request error:&error]) {
		//NSLog(@"fetchResults: %@", fetchResults);
		if ([fetchResults count]) {
			//NSLog(@"fetchResults %@", fetchResults);
			return [fetchResults objectAtIndex:0];
		} 
	} else {
		//NSLog(@"Error %@", error);
	}
	
	return [NSDictionaryToPlaylistEntryMapper convertDict:[livePlaylistCtrl.playlist objectAtIndex:selectedRow]];
}

-(BOOL)hasNext {
	for (int i = selectedRow+1; i<[livePlaylistCtrl.playlist count]; i++) {
		NSDictionary *playlistEntry = [livePlaylistCtrl.playlist objectAtIndex:i];
		NSString *entryType = [NSString stringWithFormat: @"%@", [playlistEntry objectForKey:@"entryType"]];
		
		if ([entryType isEqualToString:@"playcut"] )
		{
			return YES;
		}
	}
	
	return NO;
}

-(BOOL)hasPrev {
	for (int i = selectedRow-1; i>=0; i--) {
		NSDictionary *playlistEntry = [livePlaylistCtrl.playlist objectAtIndex:i];
		NSString *entryType = [NSString stringWithFormat: @"%@", [playlistEntry objectForKey:@"entryType"]];
		
		if ([entryType isEqualToString:@"playcut"] )
		{
			return YES;
		}
	}
	
	return NO;	
}	

@end